// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: storage.sql

package sqlc

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const createBlob = `-- name: CreateBlob :one
INSERT INTO blobs (sha256, storage_path, size, mime_type, refcount)
VALUES ($1, $2, $3, $4, $5)
RETURNING id, sha256, storage_path, size, mime_type, refcount, created_at
`

type CreateBlobParams struct {
	Sha256      string      `json:"sha256"`
	StoragePath string      `json:"storage_path"`
	Size        int64       `json:"size"`
	MimeType    pgtype.Text `json:"mime_type"`
	Refcount    int32       `json:"refcount"`
}

func (q *Queries) CreateBlob(ctx context.Context, arg CreateBlobParams) (Blob, error) {
	row := q.db.QueryRow(ctx, createBlob,
		arg.Sha256,
		arg.StoragePath,
		arg.Size,
		arg.MimeType,
		arg.Refcount,
	)
	var i Blob
	err := row.Scan(
		&i.ID,
		&i.Sha256,
		&i.StoragePath,
		&i.Size,
		&i.MimeType,
		&i.Refcount,
		&i.CreatedAt,
	)
	return i, err
}

const createFile = `-- name: CreateFile :one
INSERT INTO files (owner_id, blob_id, filename, declared_mime, size, folder_id)
VALUES ($1, $2, $3, $4, $5, $6)
RETURNING id, owner_id, blob_id, filename, declared_mime, size, uploaded_at, is_public, public_token, download_count, folder_id
`

type CreateFileParams struct {
	OwnerID      int64       `json:"owner_id"`
	BlobID       uuid.UUID   `json:"blob_id"`
	Filename     string      `json:"filename"`
	DeclaredMime pgtype.Text `json:"declared_mime"`
	Size         int64       `json:"size"`
	FolderID     pgtype.UUID `json:"folder_id"`
}

func (q *Queries) CreateFile(ctx context.Context, arg CreateFileParams) (File, error) {
	row := q.db.QueryRow(ctx, createFile,
		arg.OwnerID,
		arg.BlobID,
		arg.Filename,
		arg.DeclaredMime,
		arg.Size,
		arg.FolderID,
	)
	var i File
	err := row.Scan(
		&i.ID,
		&i.OwnerID,
		&i.BlobID,
		&i.Filename,
		&i.DeclaredMime,
		&i.Size,
		&i.UploadedAt,
		&i.IsPublic,
		&i.PublicToken,
		&i.DownloadCount,
		&i.FolderID,
	)
	return i, err
}

const createFileShare = `-- name: CreateFileShare :one
INSERT INTO file_shares (file_id, shared_with)
VALUES ($1, $2)
RETURNING id, file_id, shared_with, permission, created_at
`

type CreateFileShareParams struct {
	FileID     uuid.UUID `json:"file_id"`
	SharedWith int64     `json:"shared_with"`
}

func (q *Queries) CreateFileShare(ctx context.Context, arg CreateFileShareParams) (FileShare, error) {
	row := q.db.QueryRow(ctx, createFileShare, arg.FileID, arg.SharedWith)
	var i FileShare
	err := row.Scan(
		&i.ID,
		&i.FileID,
		&i.SharedWith,
		&i.Permission,
		&i.CreatedAt,
	)
	return i, err
}

const decrementBlobRefcount = `-- name: DecrementBlobRefcount :one
UPDATE blobs SET refcount = refcount - 1
WHERE id = $1
RETURNING refcount
`

func (q *Queries) DecrementBlobRefcount(ctx context.Context, id uuid.UUID) (int32, error) {
	row := q.db.QueryRow(ctx, decrementBlobRefcount, id)
	var refcount int32
	err := row.Scan(&refcount)
	return refcount, err
}

const decrementUserStorage = `-- name: DecrementUserStorage :exec
UPDATE users
SET original_storage_bytes = GREATEST(original_storage_bytes - $2, 0),
    dedup_storage_bytes = GREATEST(dedup_storage_bytes - $3, 0)
WHERE id = $1
`

type DecrementUserStorageParams struct {
	ID                   int64 `json:"id"`
	OriginalStorageBytes int64 `json:"original_storage_bytes"`
	DedupStorageBytes    int64 `json:"dedup_storage_bytes"`
}

func (q *Queries) DecrementUserStorage(ctx context.Context, arg DecrementUserStorageParams) error {
	_, err := q.db.Exec(ctx, decrementUserStorage, arg.ID, arg.OriginalStorageBytes, arg.DedupStorageBytes)
	return err
}

const deleteBlob = `-- name: DeleteBlob :exec
DELETE FROM blobs
WHERE id = $1
`

func (q *Queries) DeleteBlob(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteBlob, id)
	return err
}

const deleteBlobIfUnused = `-- name: DeleteBlobIfUnused :exec
DELETE FROM blobs WHERE id = $1 AND refcount <= 0
`

func (q *Queries) DeleteBlobIfUnused(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteBlobIfUnused, id)
	return err
}

const deleteFile = `-- name: DeleteFile :exec
DELETE FROM files
WHERE id = $1
`

func (q *Queries) DeleteFile(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteFile, id)
	return err
}

const deleteFileShare = `-- name: DeleteFileShare :exec
DELETE FROM file_shares
WHERE file_id = $1 AND shared_with = $2
`

type DeleteFileShareParams struct {
	FileID     uuid.UUID `json:"file_id"`
	SharedWith int64     `json:"shared_with"`
}

func (q *Queries) DeleteFileShare(ctx context.Context, arg DeleteFileShareParams) error {
	_, err := q.db.Exec(ctx, deleteFileShare, arg.FileID, arg.SharedWith)
	return err
}

const getBlobByID = `-- name: GetBlobByID :one
SELECT id, sha256, storage_path, size, mime_type, refcount, created_at FROM blobs WHERE id = $1
`

func (q *Queries) GetBlobByID(ctx context.Context, id uuid.UUID) (Blob, error) {
	row := q.db.QueryRow(ctx, getBlobByID, id)
	var i Blob
	err := row.Scan(
		&i.ID,
		&i.Sha256,
		&i.StoragePath,
		&i.Size,
		&i.MimeType,
		&i.Refcount,
		&i.CreatedAt,
	)
	return i, err
}

const getBlobBySha = `-- name: GetBlobBySha :one
SELECT id, sha256, storage_path, size, mime_type, refcount, created_at FROM blobs WHERE sha256 = $1
`

func (q *Queries) GetBlobBySha(ctx context.Context, sha256 string) (Blob, error) {
	row := q.db.QueryRow(ctx, getBlobBySha, sha256)
	var i Blob
	err := row.Scan(
		&i.ID,
		&i.Sha256,
		&i.StoragePath,
		&i.Size,
		&i.MimeType,
		&i.Refcount,
		&i.CreatedAt,
	)
	return i, err
}

const getFileByUUID = `-- name: GetFileByUUID :one
SELECT id, owner_id, blob_id, filename, declared_mime, size, uploaded_at, is_public, public_token, download_count, folder_id
FROM files f
WHERE f.id = $1
`

func (q *Queries) GetFileByUUID(ctx context.Context, id uuid.UUID) (File, error) {
	row := q.db.QueryRow(ctx, getFileByUUID, id)
	var i File
	err := row.Scan(
		&i.ID,
		&i.OwnerID,
		&i.BlobID,
		&i.Filename,
		&i.DeclaredMime,
		&i.Size,
		&i.UploadedAt,
		&i.IsPublic,
		&i.PublicToken,
		&i.DownloadCount,
		&i.FolderID,
	)
	return i, err
}

const getFilesForUser = `-- name: GetFilesForUser :many
SELECT id, filename, size, declared_mime as mime_type, uploaded_at, is_public, download_count
FROM files
WHERE owner_id = $1
AND ($4::TEXT IS NULL OR filename ILIKE '%' || $4::TEXT || '%')
ORDER BY uploaded_at DESC
LIMIT $2
OFFSET $3
`

type GetFilesForUserParams struct {
	OwnerID int64       `json:"owner_id"`
	Limit   int32       `json:"limit"`
	Offset  int32       `json:"offset"`
	Search  pgtype.Text `json:"search"`
}

type GetFilesForUserRow struct {
	ID            uuid.UUID          `json:"id"`
	Filename      string             `json:"filename"`
	Size          int64              `json:"size"`
	MimeType      pgtype.Text        `json:"mime_type"`
	UploadedAt    pgtype.Timestamptz `json:"uploaded_at"`
	IsPublic      pgtype.Bool        `json:"is_public"`
	DownloadCount pgtype.Int8        `json:"download_count"`
}

func (q *Queries) GetFilesForUser(ctx context.Context, arg GetFilesForUserParams) ([]GetFilesForUserRow, error) {
	rows, err := q.db.Query(ctx, getFilesForUser,
		arg.OwnerID,
		arg.Limit,
		arg.Offset,
		arg.Search,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetFilesForUserRow{}
	for rows.Next() {
		var i GetFilesForUserRow
		if err := rows.Scan(
			&i.ID,
			&i.Filename,
			&i.Size,
			&i.MimeType,
			&i.UploadedAt,
			&i.IsPublic,
			&i.DownloadCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getFilesForUserCount = `-- name: GetFilesForUserCount :one
SELECT count(*)
FROM files
WHERE owner_id = $1
AND ($2::TEXT IS NULL OR filename ILIKE '%' || $2::TEXT || '%')
`

type GetFilesForUserCountParams struct {
	OwnerID int64       `json:"owner_id"`
	Search  pgtype.Text `json:"search"`
}

func (q *Queries) GetFilesForUserCount(ctx context.Context, arg GetFilesForUserCountParams) (int64, error) {
	row := q.db.QueryRow(ctx, getFilesForUserCount, arg.OwnerID, arg.Search)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const incrementBlobRefcount = `-- name: IncrementBlobRefcount :one
UPDATE blobs SET refcount = refcount + 1
WHERE id = $1
RETURNING refcount
`

func (q *Queries) IncrementBlobRefcount(ctx context.Context, id uuid.UUID) (int32, error) {
	row := q.db.QueryRow(ctx, incrementBlobRefcount, id)
	var refcount int32
	err := row.Scan(&refcount)
	return refcount, err
}

const incrementFileDownloadCount = `-- name: IncrementFileDownloadCount :exec
UPDATE files
SET download_count = download_count + 1
WHERE id = $1
`

func (q *Queries) IncrementFileDownloadCount(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, incrementFileDownloadCount, id)
	return err
}

const incrementUserStorage = `-- name: IncrementUserStorage :exec
UPDATE users
SET original_storage_bytes = original_storage_bytes + $2,
    dedup_storage_bytes = dedup_storage_bytes + $3
WHERE id = $1
`

type IncrementUserStorageParams struct {
	ID                   int64 `json:"id"`
	OriginalStorageBytes int64 `json:"original_storage_bytes"`
	DedupStorageBytes    int64 `json:"dedup_storage_bytes"`
}

func (q *Queries) IncrementUserStorage(ctx context.Context, arg IncrementUserStorageParams) error {
	_, err := q.db.Exec(ctx, incrementUserStorage, arg.ID, arg.OriginalStorageBytes, arg.DedupStorageBytes)
	return err
}

const listFilesByOwner = `-- name: ListFilesByOwner :many
SELECT id, filename, size, declared_mime as content_type, uploaded_at, is_public, download_count
FROM files
WHERE owner_id = $1 AND ($2 = '' OR filename ILIKE '%' || $2 || '%')
ORDER BY uploaded_at DESC
LIMIT $3 OFFSET $4
`

type ListFilesByOwnerParams struct {
	OwnerID int64       `json:"owner_id"`
	Column2 interface{} `json:"column_2"`
	Limit   int32       `json:"limit"`
	Offset  int32       `json:"offset"`
}

type ListFilesByOwnerRow struct {
	ID            uuid.UUID          `json:"id"`
	Filename      string             `json:"filename"`
	Size          int64              `json:"size"`
	ContentType   pgtype.Text        `json:"content_type"`
	UploadedAt    pgtype.Timestamptz `json:"uploaded_at"`
	IsPublic      pgtype.Bool        `json:"is_public"`
	DownloadCount pgtype.Int8        `json:"download_count"`
}

func (q *Queries) ListFilesByOwner(ctx context.Context, arg ListFilesByOwnerParams) ([]ListFilesByOwnerRow, error) {
	rows, err := q.db.Query(ctx, listFilesByOwner,
		arg.OwnerID,
		arg.Column2,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListFilesByOwnerRow{}
	for rows.Next() {
		var i ListFilesByOwnerRow
		if err := rows.Scan(
			&i.ID,
			&i.Filename,
			&i.Size,
			&i.ContentType,
			&i.UploadedAt,
			&i.IsPublic,
			&i.DownloadCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listFilesForUser = `-- name: ListFilesForUser :many
SELECT DISTINCT 
    f.id,
    f.filename,
    f.size,
    f.declared_mime AS content_type,
    f.uploaded_at,
    (f.owner_id = $3) AS user_owns_file,
    f.download_count
FROM files f
LEFT JOIN file_shares fs ON f.id = fs.file_id
WHERE 
    (f.owner_id = $3 OR fs.shared_with = $3)
    AND ($4::TEXT = '' OR f.filename ILIKE '%' || $4::TEXT || '%')
    AND ($5::TEXT = '' OR f.declared_mime = $5::TEXT)
    AND ($6::TIMESTAMPTZ IS NULL OR f.uploaded_at > $6::TIMESTAMPTZ)
    AND ($7::TIMESTAMPTZ IS NULL OR f.uploaded_at < $7::TIMESTAMPTZ)
    AND (
        $8::int = 0
        OR ($8::int = 1 AND f.owner_id = $3)
        OR ($8::int = 2 AND f.owner_id <> $3)
    )
ORDER BY f.uploaded_at DESC
LIMIT $1 OFFSET $2
`

type ListFilesForUserParams struct {
	Limit           int32              `json:"limit"`
	Offset          int32              `json:"offset"`
	UserID          int64              `json:"user_id"`
	Filename        string             `json:"filename"`
	MimeType        string             `json:"mime_type"`
	UploadedAfter   pgtype.Timestamptz `json:"uploaded_after"`
	UploadedBefore  pgtype.Timestamptz `json:"uploaded_before"`
	OwnershipStatus int32              `json:"ownership_status"`
}

type ListFilesForUserRow struct {
	ID            uuid.UUID          `json:"id"`
	Filename      string             `json:"filename"`
	Size          int64              `json:"size"`
	ContentType   pgtype.Text        `json:"content_type"`
	UploadedAt    pgtype.Timestamptz `json:"uploaded_at"`
	UserOwnsFile  bool               `json:"user_owns_file"`
	DownloadCount pgtype.Int8        `json:"download_count"`
}

func (q *Queries) ListFilesForUser(ctx context.Context, arg ListFilesForUserParams) ([]ListFilesForUserRow, error) {
	rows, err := q.db.Query(ctx, listFilesForUser,
		arg.Limit,
		arg.Offset,
		arg.UserID,
		arg.Filename,
		arg.MimeType,
		arg.UploadedAfter,
		arg.UploadedBefore,
		arg.OwnershipStatus,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListFilesForUserRow{}
	for rows.Next() {
		var i ListFilesForUserRow
		if err := rows.Scan(
			&i.ID,
			&i.Filename,
			&i.Size,
			&i.ContentType,
			&i.UploadedAt,
			&i.UserOwnsFile,
			&i.DownloadCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listFilesSharedWithUser = `-- name: ListFilesSharedWithUser :many
SELECT f.id, f.owner_id, f.blob_id, f.filename, f.declared_mime, f.size, f.uploaded_at, f.is_public, f.public_token, f.download_count, f.folder_id
FROM files f
JOIN file_shares fs ON f.id = fs.file_id
WHERE fs.shared_with = $1
  AND ($2 = '' OR f.filename ILIKE '%' || $2 || '%')
ORDER BY f.uploaded_at DESC
LIMIT $3 OFFSET $4
`

type ListFilesSharedWithUserParams struct {
	SharedWith int64       `json:"shared_with"`
	Column2    interface{} `json:"column_2"`
	Limit      int32       `json:"limit"`
	Offset     int32       `json:"offset"`
}

func (q *Queries) ListFilesSharedWithUser(ctx context.Context, arg ListFilesSharedWithUserParams) ([]File, error) {
	rows, err := q.db.Query(ctx, listFilesSharedWithUser,
		arg.SharedWith,
		arg.Column2,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []File{}
	for rows.Next() {
		var i File
		if err := rows.Scan(
			&i.ID,
			&i.OwnerID,
			&i.BlobID,
			&i.Filename,
			&i.DeclaredMime,
			&i.Size,
			&i.UploadedAt,
			&i.IsPublic,
			&i.PublicToken,
			&i.DownloadCount,
			&i.FolderID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listFolderContents = `-- name: ListFolderContents :many
SELECT 
    f.id,
    f.name AS filename,
    'folder' AS item_type,
    NULL::bigint AS size,
    NULL::text AS content_type,
    f.created_at AS uploaded_at,
    (f.owner_id = $1) AS user_owns_file,
    NULL::bigint AS download_count,
    NULL::uuid AS folder_id
FROM folders f
WHERE 
    f.owner_id = $1
    AND f.parent_folder_id = $2::UUID
    AND ($3::TEXT = '' OR f.name ILIKE '%' || $3::TEXT || '%')

UNION ALL

SELECT
    f.id,
    f.filename,
    'file' AS item_type,
    f.size,
    f.declared_mime AS content_type,
    f.uploaded_at,
    (f.owner_id = $1) AS user_owns_file,
    f.download_count,
    f.folder_id
FROM files f
WHERE
    f.owner_id = $1
    AND f.folder_id = $2::UUID
    AND ($3::TEXT = '' OR f.filename ILIKE '%' || $3::TEXT || '%')
    AND ($4::TEXT = '' OR f.declared_mime = $4::TEXT)
    AND ($5::TIMESTAMPTZ IS NULL OR f.uploaded_at > $5::TIMESTAMPTZ)
    AND ($6::TIMESTAMPTZ IS NULL OR f.uploaded_at < $6::TIMESTAMPTZ)

ORDER BY item_type ASC, filename ASC
`

type ListFolderContentsParams struct {
	UserID         int64              `json:"user_id"`
	ParentFolderID uuid.UUID          `json:"parent_folder_id"`
	Search         string             `json:"search"`
	MimeType       string             `json:"mime_type"`
	UploadedAfter  pgtype.Timestamptz `json:"uploaded_after"`
	UploadedBefore pgtype.Timestamptz `json:"uploaded_before"`
}

type ListFolderContentsRow struct {
	ID            uuid.UUID          `json:"id"`
	Filename      string             `json:"filename"`
	ItemType      string             `json:"item_type"`
	Size          pgtype.Int8        `json:"size"`
	ContentType   pgtype.Text        `json:"content_type"`
	UploadedAt    pgtype.Timestamptz `json:"uploaded_at"`
	UserOwnsFile  bool               `json:"user_owns_file"`
	DownloadCount pgtype.Int8        `json:"download_count"`
	FolderID      pgtype.UUID        `json:"folder_id"`
}

func (q *Queries) ListFolderContents(ctx context.Context, arg ListFolderContentsParams) ([]ListFolderContentsRow, error) {
	rows, err := q.db.Query(ctx, listFolderContents,
		arg.UserID,
		arg.ParentFolderID,
		arg.Search,
		arg.MimeType,
		arg.UploadedAfter,
		arg.UploadedBefore,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListFolderContentsRow{}
	for rows.Next() {
		var i ListFolderContentsRow
		if err := rows.Scan(
			&i.ID,
			&i.Filename,
			&i.ItemType,
			&i.Size,
			&i.ContentType,
			&i.UploadedAt,
			&i.UserOwnsFile,
			&i.DownloadCount,
			&i.FolderID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listRootContents = `-- name: ListRootContents :many

SELECT
    f.id, f.name AS filename, 'folder' AS item_type, NULL::bigint AS size,
    NULL::text AS content_type, f.created_at AS uploaded_at,
    (f.owner_id = $1) AS user_owns_file,
    NULL::bigint AS download_count, NULL::uuid AS folder_id
FROM folders f
WHERE f.owner_id = $1 AND f.parent_folder_id IS NULL
  AND ($2::TEXT = '' OR f.name ILIKE '%' || $2::TEXT || '%')

UNION ALL

SELECT
    f.id, f.filename, 'file' AS item_type, f.size, f.declared_mime AS content_type,
    f.uploaded_at, (f.owner_id = $1) AS user_owns_file,
    f.download_count, f.folder_id
FROM files f
WHERE f.owner_id = $1 AND f.folder_id IS NULL
  AND ($2::TEXT = '' OR f.filename ILIKE '%' || $2::TEXT || '%')
  AND ($3::TEXT = '' OR f.declared_mime = $3::TEXT)
  AND ($4::TIMESTAMPTZ IS NULL OR f.uploaded_at > $4::TIMESTAMPTZ)
  AND ($5::TIMESTAMPTZ IS NULL OR f.uploaded_at < $5::TIMESTAMPTZ)
  AND (
      $6::int = 0
      OR ($6::int = 1 AND f.owner_id = $1)
      OR ($6::int = 2 AND f.owner_id <> $1)
  )

UNION ALL

SELECT
    f.id, f.filename, 'file' AS item_type, f.size, f.declared_mime AS content_type,
    f.uploaded_at, (f.owner_id = $1) AS user_owns_file,
    f.download_count, NULL::uuid as folder_id
FROM files f
JOIN file_shares fs ON f.id = fs.file_id
WHERE fs.shared_with = $1
  AND ($2::TEXT = '' OR f.filename ILIKE '%' || $2::TEXT || '%')
  AND ($3::TEXT = '' OR f.declared_mime = $3::TEXT)
  AND ($4::TIMESTAMPTZ IS NULL OR f.uploaded_at > $4::TIMESTAMPTZ)
  AND ($5::TIMESTAMPTZ IS NULL OR f.uploaded_at < $5::TIMESTAMPTZ)

ORDER BY item_type ASC, filename ASC
`

type ListRootContentsParams struct {
	UserID          int64              `json:"user_id"`
	Search          string             `json:"search"`
	MimeType        string             `json:"mime_type"`
	UploadedAfter   pgtype.Timestamptz `json:"uploaded_after"`
	UploadedBefore  pgtype.Timestamptz `json:"uploaded_before"`
	OwnershipStatus int32              `json:"ownership_status"`
}

type ListRootContentsRow struct {
	ID            uuid.UUID          `json:"id"`
	Filename      string             `json:"filename"`
	ItemType      string             `json:"item_type"`
	Size          pgtype.Int8        `json:"size"`
	ContentType   pgtype.Text        `json:"content_type"`
	UploadedAt    pgtype.Timestamptz `json:"uploaded_at"`
	UserOwnsFile  bool               `json:"user_owns_file"`
	DownloadCount pgtype.Int8        `json:"download_count"`
	FolderID      pgtype.UUID        `json:"folder_id"`
}

// Order folders before files
func (q *Queries) ListRootContents(ctx context.Context, arg ListRootContentsParams) ([]ListRootContentsRow, error) {
	rows, err := q.db.Query(ctx, listRootContents,
		arg.UserID,
		arg.Search,
		arg.MimeType,
		arg.UploadedAfter,
		arg.UploadedBefore,
		arg.OwnershipStatus,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListRootContentsRow{}
	for rows.Next() {
		var i ListRootContentsRow
		if err := rows.Scan(
			&i.ID,
			&i.Filename,
			&i.ItemType,
			&i.Size,
			&i.ContentType,
			&i.UploadedAt,
			&i.UserOwnsFile,
			&i.DownloadCount,
			&i.FolderID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listUsersWithAccessToFile = `-- name: ListUsersWithAccessToFile :many
SELECT u.id, u.name, u.email, fs.permission
FROM file_shares fs
JOIN users u ON u.id = fs.shared_with
WHERE fs.file_id = $1
`

type ListUsersWithAccessToFileRow struct {
	ID         int64  `json:"id"`
	Name       string `json:"name"`
	Email      string `json:"email"`
	Permission string `json:"permission"`
}

func (q *Queries) ListUsersWithAccessToFile(ctx context.Context, fileID uuid.UUID) ([]ListUsersWithAccessToFileRow, error) {
	rows, err := q.db.Query(ctx, listUsersWithAccessToFile, fileID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListUsersWithAccessToFileRow{}
	for rows.Next() {
		var i ListUsersWithAccessToFileRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Email,
			&i.Permission,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateBlobRefcount = `-- name: UpdateBlobRefcount :exec
UPDATE blobs SET refcount = refcount + $2 WHERE id = $1
`

type UpdateBlobRefcountParams struct {
	ID       uuid.UUID `json:"id"`
	Refcount int32     `json:"refcount"`
}

func (q *Queries) UpdateBlobRefcount(ctx context.Context, arg UpdateBlobRefcountParams) error {
	_, err := q.db.Exec(ctx, updateBlobRefcount, arg.ID, arg.Refcount)
	return err
}

const updateFilename = `-- name: UpdateFilename :one
UPDATE files
SET filename = $1
WHERE id = $2
RETURNING id, owner_id, blob_id, filename, declared_mime, size, uploaded_at, is_public, public_token, download_count, folder_id
`

type UpdateFilenameParams struct {
	Filename string    `json:"filename"`
	ID       uuid.UUID `json:"id"`
}

func (q *Queries) UpdateFilename(ctx context.Context, arg UpdateFilenameParams) (File, error) {
	row := q.db.QueryRow(ctx, updateFilename, arg.Filename, arg.ID)
	var i File
	err := row.Scan(
		&i.ID,
		&i.OwnerID,
		&i.BlobID,
		&i.Filename,
		&i.DeclaredMime,
		&i.Size,
		&i.UploadedAt,
		&i.IsPublic,
		&i.PublicToken,
		&i.DownloadCount,
		&i.FolderID,
	)
	return i, err
}

const userHasAccess = `-- name: UserHasAccess :one
SELECT EXISTS (
  SELECT 1
  FROM files f
  LEFT JOIN file_shares fs
    ON f.id = fs.file_id AND fs.shared_with = $1
  WHERE f.id = $2
    AND (f.owner_id = $1 OR fs.shared_with = $1)
)
`

type UserHasAccessParams struct {
	SharedWith int64     `json:"shared_with"`
	ID         uuid.UUID `json:"id"`
}

func (q *Queries) UserHasAccess(ctx context.Context, arg UserHasAccessParams) (bool, error) {
	row := q.db.QueryRow(ctx, userHasAccess, arg.SharedWith, arg.ID)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const userOwnsBlob = `-- name: UserOwnsBlob :one
SELECT 1 FROM files WHERE owner_id = $1 AND blob_id = $2 LIMIT 1
`

type UserOwnsBlobParams struct {
	OwnerID int64     `json:"owner_id"`
	BlobID  uuid.UUID `json:"blob_id"`
}

func (q *Queries) UserOwnsBlob(ctx context.Context, arg UserOwnsBlobParams) (int32, error) {
	row := q.db.QueryRow(ctx, userOwnsBlob, arg.OwnerID, arg.BlobID)
	var column_1 int32
	err := row.Scan(&column_1)
	return column_1, err
}
