// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: storage.sql

package sqlc

import (
	"context"
	"database/sql"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

type AddSharesToFileParams struct {
	FileID     uuid.UUID `json:"file_id"`
	SharedWith int64     `json:"shared_with"`
}

const createBlob = `-- name: CreateBlob :one
INSERT INTO blobs (sha256, storage_path, size, mime_type, refcount)
VALUES ($1, $2, $3, $4, $5)
RETURNING id, sha256, storage_path, size, mime_type, refcount, created_at
`

type CreateBlobParams struct {
	Sha256      string      `json:"sha256"`
	StoragePath string      `json:"storage_path"`
	Size        int64       `json:"size"`
	MimeType    pgtype.Text `json:"mime_type"`
	Refcount    int32       `json:"refcount"`
}

func (q *Queries) CreateBlob(ctx context.Context, arg CreateBlobParams) (Blob, error) {
	row := q.db.QueryRow(ctx, createBlob,
		arg.Sha256,
		arg.StoragePath,
		arg.Size,
		arg.MimeType,
		arg.Refcount,
	)
	var i Blob
	err := row.Scan(
		&i.ID,
		&i.Sha256,
		&i.StoragePath,
		&i.Size,
		&i.MimeType,
		&i.Refcount,
		&i.CreatedAt,
	)
	return i, err
}

const createFile = `-- name: CreateFile :one
INSERT INTO files (owner_id, blob_id, filename, declared_mime, size, folder_id)
VALUES ($1, $2, $3, $4, $5, $6)
RETURNING id, owner_id, blob_id, filename, declared_mime, size, uploaded_at, is_public, public_token, download_count, folder_id
`

type CreateFileParams struct {
	OwnerID      int64       `json:"owner_id"`
	BlobID       uuid.UUID   `json:"blob_id"`
	Filename     string      `json:"filename"`
	DeclaredMime pgtype.Text `json:"declared_mime"`
	Size         int64       `json:"size"`
	FolderID     pgtype.UUID `json:"folder_id"`
}

func (q *Queries) CreateFile(ctx context.Context, arg CreateFileParams) (File, error) {
	row := q.db.QueryRow(ctx, createFile,
		arg.OwnerID,
		arg.BlobID,
		arg.Filename,
		arg.DeclaredMime,
		arg.Size,
		arg.FolderID,
	)
	var i File
	err := row.Scan(
		&i.ID,
		&i.OwnerID,
		&i.BlobID,
		&i.Filename,
		&i.DeclaredMime,
		&i.Size,
		&i.UploadedAt,
		&i.IsPublic,
		&i.PublicToken,
		&i.DownloadCount,
		&i.FolderID,
	)
	return i, err
}

const deleteAllSharesForFile = `-- name: DeleteAllSharesForFile :exec
DELETE FROM file_shares
WHERE file_id = $1
`

func (q *Queries) DeleteAllSharesForFile(ctx context.Context, fileID uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteAllSharesForFile, fileID)
	return err
}

const deleteBlob = `-- name: DeleteBlob :exec
DELETE FROM blobs
WHERE id = $1
`

func (q *Queries) DeleteBlob(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteBlob, id)
	return err
}

const deleteBlobIfUnused = `-- name: DeleteBlobIfUnused :one
DELETE FROM blobs 
WHERE id = $1 AND refcount <= 0
RETURNING storage_path
`

func (q *Queries) DeleteBlobIfUnused(ctx context.Context, id uuid.UUID) (string, error) {
	row := q.db.QueryRow(ctx, deleteBlobIfUnused, id)
	var storage_path string
	err := row.Scan(&storage_path)
	return storage_path, err
}

const deleteBlobsByStoragePaths = `-- name: DeleteBlobsByStoragePaths :exec
DELETE FROM blobs
WHERE storage_path = ANY($1::text[]) AND refcount <= 1
`

func (q *Queries) DeleteBlobsByStoragePaths(ctx context.Context, storagePaths []string) error {
	_, err := q.db.Exec(ctx, deleteBlobsByStoragePaths, storagePaths)
	return err
}

const deleteFile = `-- name: DeleteFile :exec
DELETE FROM files
WHERE id = $1
`

func (q *Queries) DeleteFile(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteFile, id)
	return err
}

const getBlobByID = `-- name: GetBlobByID :one
SELECT id, sha256, storage_path, size, mime_type, refcount, created_at FROM blobs WHERE id = $1
`

func (q *Queries) GetBlobByID(ctx context.Context, id uuid.UUID) (Blob, error) {
	row := q.db.QueryRow(ctx, getBlobByID, id)
	var i Blob
	err := row.Scan(
		&i.ID,
		&i.Sha256,
		&i.StoragePath,
		&i.Size,
		&i.MimeType,
		&i.Refcount,
		&i.CreatedAt,
	)
	return i, err
}

const getBlobBySha = `-- name: GetBlobBySha :one
SELECT id, sha256, storage_path, size, mime_type, refcount, created_at FROM blobs WHERE sha256 = $1 LIMIT 1
`

func (q *Queries) GetBlobBySha(ctx context.Context, sha256 string) (Blob, error) {
	row := q.db.QueryRow(ctx, getBlobBySha, sha256)
	var i Blob
	err := row.Scan(
		&i.ID,
		&i.Sha256,
		&i.StoragePath,
		&i.Size,
		&i.MimeType,
		&i.Refcount,
		&i.CreatedAt,
	)
	return i, err
}

const getBlobIDsInFolderHierarchy = `-- name: GetBlobIDsInFolderHierarchy :many
WITH RECURSIVE folder_hierarchy AS (
    -- This part is correct and finds all sub-folder IDs
    SELECT fo.id FROM folders fo WHERE fo.id = $1
    UNION ALL
    SELECT f.id FROM folders f
    INNER JOIN folder_hierarchy fh ON f.parent_folder_id = fh.id
)
SELECT DISTINCT f.blob_id
FROM files f
WHERE f.folder_id IN (SELECT id FROM folder_hierarchy)
`

func (q *Queries) GetBlobIDsInFolderHierarchy(ctx context.Context, id uuid.UUID) ([]uuid.UUID, error) {
	rows, err := q.db.Query(ctx, getBlobIDsInFolderHierarchy, id)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []uuid.UUID{}
	for rows.Next() {
		var blob_id uuid.UUID
		if err := rows.Scan(&blob_id); err != nil {
			return nil, err
		}
		items = append(items, blob_id)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getFileByUUID = `-- name: GetFileByUUID :one
SELECT id, owner_id, blob_id, filename, declared_mime, size, uploaded_at, is_public, public_token, download_count, folder_id
FROM files f
WHERE f.id = $1
`

func (q *Queries) GetFileByUUID(ctx context.Context, id uuid.UUID) (File, error) {
	row := q.db.QueryRow(ctx, getFileByUUID, id)
	var i File
	err := row.Scan(
		&i.ID,
		&i.OwnerID,
		&i.BlobID,
		&i.Filename,
		&i.DeclaredMime,
		&i.Size,
		&i.UploadedAt,
		&i.IsPublic,
		&i.PublicToken,
		&i.DownloadCount,
		&i.FolderID,
	)
	return i, err
}

const getFilesForUser = `-- name: GetFilesForUser :many
SELECT id, filename, size, declared_mime as mime_type, uploaded_at, is_public, download_count
FROM files
WHERE owner_id = $1
AND ($4::TEXT IS NULL OR filename ILIKE '%' || $4::TEXT || '%')
ORDER BY uploaded_at DESC
LIMIT $2
OFFSET $3
`

type GetFilesForUserParams struct {
	OwnerID int64       `json:"owner_id"`
	Limit   int32       `json:"limit"`
	Offset  int32       `json:"offset"`
	Search  pgtype.Text `json:"search"`
}

type GetFilesForUserRow struct {
	ID            uuid.UUID          `json:"id"`
	Filename      string             `json:"filename"`
	Size          int64              `json:"size"`
	MimeType      pgtype.Text        `json:"mime_type"`
	UploadedAt    pgtype.Timestamptz `json:"uploaded_at"`
	IsPublic      pgtype.Bool        `json:"is_public"`
	DownloadCount sql.NullInt64      `json:"download_count"`
}

func (q *Queries) GetFilesForUser(ctx context.Context, arg GetFilesForUserParams) ([]GetFilesForUserRow, error) {
	rows, err := q.db.Query(ctx, getFilesForUser,
		arg.OwnerID,
		arg.Limit,
		arg.Offset,
		arg.Search,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetFilesForUserRow{}
	for rows.Next() {
		var i GetFilesForUserRow
		if err := rows.Scan(
			&i.ID,
			&i.Filename,
			&i.Size,
			&i.MimeType,
			&i.UploadedAt,
			&i.IsPublic,
			&i.DownloadCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getFilesForUserCount = `-- name: GetFilesForUserCount :one
SELECT count(*)
FROM files
WHERE owner_id = $1
AND ($2::TEXT IS NULL OR filename ILIKE '%' || $2::TEXT || '%')
`

type GetFilesForUserCountParams struct {
	OwnerID int64       `json:"owner_id"`
	Search  pgtype.Text `json:"search"`
}

func (q *Queries) GetFilesForUserCount(ctx context.Context, arg GetFilesForUserCountParams) (int64, error) {
	row := q.db.QueryRow(ctx, getFilesForUserCount, arg.OwnerID, arg.Search)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const incrementFileDownloadCount = `-- name: IncrementFileDownloadCount :exec
UPDATE files
SET download_count = download_count + 1
WHERE id = $1
`

func (q *Queries) IncrementFileDownloadCount(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, incrementFileDownloadCount, id)
	return err
}

const listAllFiles = `-- name: ListAllFiles :many
SELECT
    f.id,
    f.filename,
    f.size,
    f.declared_mime,
    f.uploaded_at,
    f.download_count,
    f.owner_id,
    u.email as owner_email,
    COUNT(*) OVER() AS total_count
FROM
    files f
JOIN
    users u ON f.owner_id = u.id 
ORDER BY 
    CASE WHEN $3::text = 'asc' THEN
        CASE $4::text
            WHEN 'filename' THEN f.filename::text
            WHEN 'owner_email' THEN u.email::text
            -- Pad numbers to ensure correct alphabetical sorting
            WHEN 'size' THEN LPAD(f.size::text, 20, '0')
            WHEN 'download_count' THEN LPAD(f.download_count::text, 20, '0')
            -- Timestamps in ISO format sort correctly as text
            WHEN 'uploaded_at' THEN f.uploaded_at::text
            ELSE f.uploaded_at::text
        END
    END ASC,
    CASE WHEN $3::text = 'desc' THEN
        CASE $4::text
            WHEN 'filename' THEN f.filename::text
            WHEN 'owner_email' THEN u.email::text
            WHEN 'size' THEN LPAD(f.size::text, 20, '0')
            WHEN 'download_count' THEN LPAD(f.download_count::text, 20, '0')
            WHEN 'uploaded_at' THEN f.uploaded_at::text
            ELSE f.uploaded_at::text
        END
    END DESC 
LIMIT $1 OFFSET $2
`

type ListAllFilesParams struct {
	Limit     int32  `json:"limit"`
	Offset    int32  `json:"offset"`
	SortOrder string `json:"sort_order"`
	SortBy    string `json:"sort_by"`
}

type ListAllFilesRow struct {
	ID            uuid.UUID          `json:"id"`
	Filename      string             `json:"filename"`
	Size          int64              `json:"size"`
	DeclaredMime  pgtype.Text        `json:"declared_mime"`
	UploadedAt    pgtype.Timestamptz `json:"uploaded_at"`
	DownloadCount sql.NullInt64      `json:"download_count"`
	OwnerID       int64              `json:"owner_id"`
	OwnerEmail    string             `json:"owner_email"`
	TotalCount    int64              `json:"total_count"`
}

func (q *Queries) ListAllFiles(ctx context.Context, arg ListAllFilesParams) ([]ListAllFilesRow, error) {
	rows, err := q.db.Query(ctx, listAllFiles,
		arg.Limit,
		arg.Offset,
		arg.SortOrder,
		arg.SortBy,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListAllFilesRow{}
	for rows.Next() {
		var i ListAllFilesRow
		if err := rows.Scan(
			&i.ID,
			&i.Filename,
			&i.Size,
			&i.DeclaredMime,
			&i.UploadedAt,
			&i.DownloadCount,
			&i.OwnerID,
			&i.OwnerEmail,
			&i.TotalCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listFilesByOwner = `-- name: ListFilesByOwner :many
SELECT id, filename, size, declared_mime as content_type, uploaded_at, is_public, download_count
FROM files
WHERE owner_id = $1 AND ($2 = '' OR filename ILIKE '%' || $2 || '%')
ORDER BY uploaded_at DESC
LIMIT $3 OFFSET $4
`

type ListFilesByOwnerParams struct {
	OwnerID int64       `json:"owner_id"`
	Column2 interface{} `json:"column_2"`
	Limit   int32       `json:"limit"`
	Offset  int32       `json:"offset"`
}

type ListFilesByOwnerRow struct {
	ID            uuid.UUID          `json:"id"`
	Filename      string             `json:"filename"`
	Size          int64              `json:"size"`
	ContentType   pgtype.Text        `json:"content_type"`
	UploadedAt    pgtype.Timestamptz `json:"uploaded_at"`
	IsPublic      pgtype.Bool        `json:"is_public"`
	DownloadCount sql.NullInt64      `json:"download_count"`
}

func (q *Queries) ListFilesByOwner(ctx context.Context, arg ListFilesByOwnerParams) ([]ListFilesByOwnerRow, error) {
	rows, err := q.db.Query(ctx, listFilesByOwner,
		arg.OwnerID,
		arg.Column2,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListFilesByOwnerRow{}
	for rows.Next() {
		var i ListFilesByOwnerRow
		if err := rows.Scan(
			&i.ID,
			&i.Filename,
			&i.Size,
			&i.ContentType,
			&i.UploadedAt,
			&i.IsPublic,
			&i.DownloadCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listFilesSharedWithUser = `-- name: ListFilesSharedWithUser :many
SELECT f.id, f.owner_id, f.blob_id, f.filename, f.declared_mime, f.size, f.uploaded_at, f.is_public, f.public_token, f.download_count, f.folder_id
FROM files f
JOIN file_shares fs ON f.id = fs.file_id
WHERE fs.shared_with = $1
  AND ($2 = '' OR f.filename ILIKE '%' || $2 || '%')
ORDER BY f.uploaded_at DESC
LIMIT $3 OFFSET $4
`

type ListFilesSharedWithUserParams struct {
	SharedWith int64       `json:"shared_with"`
	Column2    interface{} `json:"column_2"`
	Limit      int32       `json:"limit"`
	Offset     int32       `json:"offset"`
}

func (q *Queries) ListFilesSharedWithUser(ctx context.Context, arg ListFilesSharedWithUserParams) ([]File, error) {
	rows, err := q.db.Query(ctx, listFilesSharedWithUser,
		arg.SharedWith,
		arg.Column2,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []File{}
	for rows.Next() {
		var i File
		if err := rows.Scan(
			&i.ID,
			&i.OwnerID,
			&i.BlobID,
			&i.Filename,
			&i.DeclaredMime,
			&i.Size,
			&i.UploadedAt,
			&i.IsPublic,
			&i.PublicToken,
			&i.DownloadCount,
			&i.FolderID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listFolderContents = `-- name: ListFolderContents :many

WITH folder_contents AS (
    SELECT 
        f.id,
        f.name AS filename,
        'folder' AS item_type,
        NULL::bigint AS size,
        NULL::text AS content_type,
        f.created_at AS uploaded_at,
        (f.owner_id = $5) AS user_owns_file,
        NULL::bigint AS download_count,
        NULL::uuid AS folder_id
    FROM folders f
    WHERE 
        f.owner_id = $5
        AND f.parent_folder_id = $6::UUID
        AND ($7::TEXT = '' OR f.name ILIKE '%' || $7::TEXT || '%')
        AND ($8::TEXT = 'folder/folder' OR $8::TEXT = '')

    UNION ALL

    SELECT
        f.id,
        f.filename,
        'file' AS item_type,
        f.size,
        f.declared_mime AS content_type,
        f.uploaded_at,
        (f.owner_id = $5) AS user_owns_file,
        f.download_count,
        f.folder_id
    FROM files f
    WHERE
        f.owner_id = $5
        AND f.folder_id = $6::UUID
        AND ($7::TEXT = '' OR f.filename ILIKE '%' || $7::TEXT || '%')
        AND ($8::TEXT = '' OR f.declared_mime = $8::TEXT)
        AND ($9::TIMESTAMPTZ IS NULL OR f.uploaded_at > $9::TIMESTAMPTZ)
        AND ($10::TIMESTAMPTZ IS NULL OR f.uploaded_at < $10::TIMESTAMPTZ)
        AND ($11::BIGINT IS NULL OR f.size >= $11::BIGINT)
        AND ($12::BIGINT IS NULL OR f.size <= $12::BIGINT)
) 
SELECT id, filename, item_type, size, content_type, uploaded_at, user_owns_file, download_count, folder_id, COUNT(*) OVER() AS total_count 
FROM folder_contents
ORDER BY 
    item_type DESC,
    CASE WHEN $3::text = 'filename' AND $4::text = 'asc' THEN filename END ASC,
    CASE WHEN $3::text = 'filename' AND $4::text = 'desc' THEN filename END DESC,
    CASE WHEN $3::text = 'size' AND $4::text = 'asc' THEN size END ASC NULLS FIRST,
    CASE WHEN $3::text = 'size' AND $4::text = 'desc' THEN size END DESC NULLS LAST,
    CASE WHEN $3::text = 'uploaded_at' AND $4::text = 'asc' THEN uploaded_at END ASC,
    CASE WHEN $3::text = 'uploaded_at' AND $4::text = 'desc' THEN uploaded_at END DESC
LIMIT $1 OFFSET $2
`

type ListFolderContentsParams struct {
	Limit          int32              `json:"limit"`
	Offset         int32              `json:"offset"`
	SortBy         string             `json:"sort_by"`
	SortOrder      string             `json:"sort_order"`
	UserID         int64              `json:"user_id"`
	ParentFolderID uuid.UUID          `json:"parent_folder_id"`
	Search         string             `json:"search"`
	MimeType       string             `json:"mime_type"`
	UploadedAfter  pgtype.Timestamptz `json:"uploaded_after"`
	UploadedBefore pgtype.Timestamptz `json:"uploaded_before"`
	MinSize        sql.NullInt64      `json:"min_size"`
	MaxSize        sql.NullInt64      `json:"max_size"`
}

type ListFolderContentsRow struct {
	ID            uuid.UUID          `json:"id"`
	Filename      string             `json:"filename"`
	ItemType      string             `json:"item_type"`
	Size          sql.NullInt64      `json:"size"`
	ContentType   pgtype.Text        `json:"content_type"`
	UploadedAt    pgtype.Timestamptz `json:"uploaded_at"`
	UserOwnsFile  bool               `json:"user_owns_file"`
	DownloadCount sql.NullInt64      `json:"download_count"`
	FolderID      pgtype.UUID        `json:"folder_id"`
	TotalCount    int64              `json:"total_count"`
}

// ---------------------------
func (q *Queries) ListFolderContents(ctx context.Context, arg ListFolderContentsParams) ([]ListFolderContentsRow, error) {
	rows, err := q.db.Query(ctx, listFolderContents,
		arg.Limit,
		arg.Offset,
		arg.SortBy,
		arg.SortOrder,
		arg.UserID,
		arg.ParentFolderID,
		arg.Search,
		arg.MimeType,
		arg.UploadedAfter,
		arg.UploadedBefore,
		arg.MinSize,
		arg.MaxSize,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListFolderContentsRow{}
	for rows.Next() {
		var i ListFolderContentsRow
		if err := rows.Scan(
			&i.ID,
			&i.Filename,
			&i.ItemType,
			&i.Size,
			&i.ContentType,
			&i.UploadedAt,
			&i.UserOwnsFile,
			&i.DownloadCount,
			&i.FolderID,
			&i.TotalCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listRootContents = `-- name: ListRootContents :many
WITH root_contents AS (
    SELECT
        f.id, f.name AS filename, 'folder' AS item_type, NULL::bigint AS size,
        NULL::text AS content_type, f.created_at AS uploaded_at,
        (f.owner_id = $5) AS user_owns_file,
        NULL::bigint AS download_count, NULL::uuid AS folder_id
    FROM folders f
    WHERE f.owner_id = $5 AND f.parent_folder_id IS NULL
      AND ($6::TEXT = '' OR f.name ILIKE '%' || $6::TEXT || '%')
      AND ($7::TEXT = 'folder/folder' OR $7::TEXT = '')

    UNION ALL

    SELECT
        f.id, f.filename, 'file' AS item_type, f.size, f.declared_mime AS content_type,
        f.uploaded_at, (f.owner_id = $5) AS user_owns_file,
        f.download_count, f.folder_id
    FROM files f
    WHERE f.owner_id = $5 AND f.folder_id IS NULL
        AND ($6::TEXT = '' OR f.filename ILIKE '%' || $6::TEXT || '%')
        AND ($7::TEXT = '' OR f.declared_mime = $7::TEXT)
        AND ($8::TIMESTAMPTZ IS NULL OR f.uploaded_at > $8::TIMESTAMPTZ)
        AND ($9::TIMESTAMPTZ IS NULL OR f.uploaded_at < $9::TIMESTAMPTZ)
        AND ($10::BIGINT IS NULL OR f.size >= $10::BIGINT)
        AND ($11::BIGINT IS NULL OR f.size <= $11::BIGINT)
        AND (
            $12::int = 0
            OR ($12::int = 1 AND f.owner_id = $5)
            OR ($12::int = 2 AND f.owner_id <> $5)
          )

    UNION ALL

    SELECT
        f.id, f.filename, 'file' AS item_type, f.size, f.declared_mime AS content_type,
        f.uploaded_at, (f.owner_id = $5) AS user_owns_file,
        f.download_count, NULL::uuid as folder_id
    FROM files f
    JOIN file_shares fs ON f.id = fs.file_id
    WHERE fs.shared_with = $5
      AND ($6::TEXT = '' OR f.filename ILIKE '%' || $6::TEXT || '%')
      AND ($7::TEXT = '' OR f.declared_mime = $7::TEXT)
      AND ($8::TIMESTAMPTZ IS NULL OR f.uploaded_at > $8::TIMESTAMPTZ)
      AND ($9::TIMESTAMPTZ IS NULL OR f.uploaded_at < $9::TIMESTAMPTZ)
      AND ($10::BIGINT IS NULL OR f.size >= $10::BIGINT)
      AND ($11::BIGINT IS NULL OR f.size <= $11::BIGINT)
) 
SELECT id, filename, item_type, size, content_type, uploaded_at, user_owns_file, download_count, folder_id, COUNT(*) OVER() AS total_count 
FROM root_contents
ORDER BY
    item_type DESC,
    CASE WHEN $3::text = 'filename' AND $4::text = 'asc' THEN filename END ASC,
    CASE WHEN $3::text = 'filename' AND $4::text = 'desc' THEN filename END DESC,
    CASE WHEN $3::text = 'size' AND $4::text = 'asc' THEN size END ASC NULLS FIRST,
    CASE WHEN $3::text = 'size' AND $4::text = 'desc' THEN size END DESC NULLS LAST,
    CASE WHEN $3::text = 'uploaded_at' AND $4::text = 'asc' THEN uploaded_at END ASC,
    CASE WHEN $3::text = 'uploaded_at' AND $4::text = 'desc' THEN uploaded_at END DESC
LIMIT $1 OFFSET $2
`

type ListRootContentsParams struct {
	Limit           int32              `json:"limit"`
	Offset          int32              `json:"offset"`
	SortBy          string             `json:"sort_by"`
	SortOrder       string             `json:"sort_order"`
	UserID          int64              `json:"user_id"`
	Search          string             `json:"search"`
	MimeType        string             `json:"mime_type"`
	UploadedAfter   pgtype.Timestamptz `json:"uploaded_after"`
	UploadedBefore  pgtype.Timestamptz `json:"uploaded_before"`
	MinSize         sql.NullInt64      `json:"min_size"`
	MaxSize         sql.NullInt64      `json:"max_size"`
	OwnershipStatus int32              `json:"ownership_status"`
}

type ListRootContentsRow struct {
	ID            uuid.UUID          `json:"id"`
	Filename      string             `json:"filename"`
	ItemType      string             `json:"item_type"`
	Size          sql.NullInt64      `json:"size"`
	ContentType   pgtype.Text        `json:"content_type"`
	UploadedAt    pgtype.Timestamptz `json:"uploaded_at"`
	UserOwnsFile  bool               `json:"user_owns_file"`
	DownloadCount sql.NullInt64      `json:"download_count"`
	FolderID      pgtype.UUID        `json:"folder_id"`
	TotalCount    int64              `json:"total_count"`
}

func (q *Queries) ListRootContents(ctx context.Context, arg ListRootContentsParams) ([]ListRootContentsRow, error) {
	rows, err := q.db.Query(ctx, listRootContents,
		arg.Limit,
		arg.Offset,
		arg.SortBy,
		arg.SortOrder,
		arg.UserID,
		arg.Search,
		arg.MimeType,
		arg.UploadedAfter,
		arg.UploadedBefore,
		arg.MinSize,
		arg.MaxSize,
		arg.OwnershipStatus,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListRootContentsRow{}
	for rows.Next() {
		var i ListRootContentsRow
		if err := rows.Scan(
			&i.ID,
			&i.Filename,
			&i.ItemType,
			&i.Size,
			&i.ContentType,
			&i.UploadedAt,
			&i.UserOwnsFile,
			&i.DownloadCount,
			&i.FolderID,
			&i.TotalCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listUsersWithAccessToFile = `-- name: ListUsersWithAccessToFile :many
SELECT u.id, u.name, u.email, fs.permission
FROM file_shares fs
JOIN users u ON u.id = fs.shared_with
WHERE fs.file_id = $1
`

type ListUsersWithAccessToFileRow struct {
	ID         int64  `json:"id"`
	Name       string `json:"name"`
	Email      string `json:"email"`
	Permission string `json:"permission"`
}

func (q *Queries) ListUsersWithAccessToFile(ctx context.Context, fileID uuid.UUID) ([]ListUsersWithAccessToFileRow, error) {
	rows, err := q.db.Query(ctx, listUsersWithAccessToFile, fileID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListUsersWithAccessToFileRow{}
	for rows.Next() {
		var i ListUsersWithAccessToFileRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Email,
			&i.Permission,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateFileFolder = `-- name: UpdateFileFolder :exec
UPDATE files
SET folder_id = $1
WHERE id = $2
`

type UpdateFileFolderParams struct {
	FolderID pgtype.UUID `json:"folder_id"`
	ID       uuid.UUID   `json:"id"`
}

func (q *Queries) UpdateFileFolder(ctx context.Context, arg UpdateFileFolderParams) error {
	_, err := q.db.Exec(ctx, updateFileFolder, arg.FolderID, arg.ID)
	return err
}

const updateFilename = `-- name: UpdateFilename :one
UPDATE files
SET filename = $1
WHERE id = $2
RETURNING id, owner_id, blob_id, filename, declared_mime, size, uploaded_at, is_public, public_token, download_count, folder_id
`

type UpdateFilenameParams struct {
	Filename string    `json:"filename"`
	ID       uuid.UUID `json:"id"`
}

func (q *Queries) UpdateFilename(ctx context.Context, arg UpdateFilenameParams) (File, error) {
	row := q.db.QueryRow(ctx, updateFilename, arg.Filename, arg.ID)
	var i File
	err := row.Scan(
		&i.ID,
		&i.OwnerID,
		&i.BlobID,
		&i.Filename,
		&i.DeclaredMime,
		&i.Size,
		&i.UploadedAt,
		&i.IsPublic,
		&i.PublicToken,
		&i.DownloadCount,
		&i.FolderID,
	)
	return i, err
}

const userHasAccess = `-- name: UserHasAccess :one
SELECT EXISTS (
  SELECT 1
  FROM files f
  LEFT JOIN file_shares fs
    ON f.id = fs.file_id AND fs.shared_with = $1
  WHERE f.id = $2
    AND (f.owner_id = $1 OR fs.shared_with = $1)
)
`

type UserHasAccessParams struct {
	SharedWith int64     `json:"shared_with"`
	ID         uuid.UUID `json:"id"`
}

func (q *Queries) UserHasAccess(ctx context.Context, arg UserHasAccessParams) (bool, error) {
	row := q.db.QueryRow(ctx, userHasAccess, arg.SharedWith, arg.ID)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const userOwnsBlob = `-- name: UserOwnsBlob :one
SELECT 1 FROM files WHERE owner_id = $1 AND blob_id = $2 LIMIT 1
`

type UserOwnsBlobParams struct {
	OwnerID int64     `json:"owner_id"`
	BlobID  uuid.UUID `json:"blob_id"`
}

func (q *Queries) UserOwnsBlob(ctx context.Context, arg UserOwnsBlobParams) (int32, error) {
	row := q.db.QueryRow(ctx, userOwnsBlob, arg.OwnerID, arg.BlobID)
	var column_1 int32
	err := row.Scan(&column_1)
	return column_1, err
}
